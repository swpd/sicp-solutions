(define (make-interval a b) (cons a b))

(define (upper-bound i)
  (max (car i)
       (cdr i)))

(define (lower-bound i)
  (min (car i)
       (cdr i)))

(define (sign x)
  (let ((lx (lower-bound x))
        (ux (upper-bound x)))
    (cond ((and (< lx 0) (< ux 0)) 1)
          ((and (> lx 0) (> ux 0)) 2)
          (else 3))))

(define (mul-interval x y)
  (let ((lx (lower-bound x))
        (ux (upper-bound x))
        (ly (lower-bound y))
        (uy (upper-bound y))
        (sx (sign x))
        (sy (sign y)))
    (cond ((= sx 1)
           (cond ((= sy 1)
                  (make-interval (* ux uy)
                                 (* lx ly)))
                 ((= sy 2)
                  (make-interval (* lx uy)
                                 (* ux ly)))
                 (else
                  (make-interval (* lx uy)
                                 (* lx ly)))))
          ((= sx 2)
           (cond ((= sy 1)
                  (make-interval (* ux ly)
                                 (* lx uy)))
                 ((= sy 2)
                  (make-interval (* lx ly)
                                 (* ux uy)))
                 (else
                  (make-interval (* ux ly)
                                 (* ux uy)))))
          (else
           (cond ((= sy 1)
                  (make-interval (* ux ly)
                                 (* lx ly)))
                 ((= sy 2)
                  (make-interval (* lx uy)
                                 (* ux uy)))
                 (else
                  (make-interval (min (* lx uy)
                                      (* ly ux))
                                 (max (* lx ly)
                                      (* ux uy)))))))))
